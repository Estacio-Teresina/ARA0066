# **Aula 07**

Sumário

- [**Aula 07**](#aula-07)
  - [**Expressões e sentenças de atribuição**](#expressões-e-sentenças-de-atribuição)
    - [**Expressões relacionais e booleanas**](#expressões-relacionais-e-booleanas)
      - [**Expressões relacionais**](#expressões-relacionais)
      - [**Expressões booleanas**](#expressões-booleanas)
    - [**Avaliação em Curto-Circuito**](#avaliação-em-curto-circuito)
    - [**Sentenças de Atribuição**](#sentenças-de-atribuição)
      - [**Atribuições simples**](#atribuições-simples)
      - [**Alvos condicionais**](#alvos-condicionais)
      - [**Operadores de atribuição compostos**](#operadores-de-atribuição-compostos)
      - [**Operadores de atribuição unários**](#operadores-de-atribuição-unários)
      - [**Atribuição como uma expressão**](#atribuição-como-uma-expressão)
      - [**Atribuições múltiplas**](#atribuições-múltiplas)
  - [**Subprogramas**](#subprogramas)
    - [**Introdução**](#introdução)
    - [**Fundamentos dos subprogramas**](#fundamentos-dos-subprogramas)
      - [**Características gerais dos subprogramas**](#características-gerais-dos-subprogramas)
      - [**Definições básicas**](#definições-básicas)
      - [**Parâmetros**](#parâmetros)
      - [**Procedimentos e funções**](#procedimentos-e-funções)
    - [**Questões de projeto para subprogramas**](#questões-de-projeto-para-subprogramas)
    - [**Ambientes de referenciamento local**](#ambientes-de-referenciamento-local)
      - [**Variáveis locais**](#variáveis-locais)
      - [**Subprogramas aninhados**](#subprogramas-aninhados)
    - [**Métodos de passagem de parâmetros**](#métodos-de-passagem-de-parâmetros)
      - [**Modelos semânticos de passagem de parâmetros**](#modelos-semânticos-de-passagem-de-parâmetros)
      - [**Modelos de implementação de passagem de parâmetros**](#modelos-de-implementação-de-passagem-de-parâmetros)
        - [**Passagem por valor**](#passagem-por-valor)
        - [**Passagem por resultado**](#passagem-por-resultado)
        - [**Passagem por valor-resultado**](#passagem-por-valor-resultado)
        - [**Passagem por referência**](#passagem-por-referência)
        - [**Passagem por nome**](#passagem-por-nome)
    - [**Parâmetros que são subprogramas**](#parâmetros-que-são-subprogramas)
    - [**Chamada indireta de subprogramas**](#chamada-indireta-de-subprogramas)
    - [**Questões de projeto para funções**](#questões-de-projeto-para-funções)
      - [**Efeitos colaterais funcionais**](#efeitos-colaterais-funcionais)
      - [**Tipos de valores retornados**](#tipos-de-valores-retornados)
      - [**Números de valores retornados**](#números-de-valores-retornados)
    - [**Subprogramas sobrecarregados**](#subprogramas-sobrecarregados)
    - [**Subprogramas genéricos**](#subprogramas-genéricos)
    - [**Operadores sobrecarregados definidos pelo usuário**](#operadores-sobrecarregados-definidos-pelo-usuário)
    - [**Fechamentos**](#fechamentos)
    - [**Corrotinas**](#corrotinas)
  - [**Vídeos**](#vídeos)
  - [**Exercícios**](#exercícios)


## **Expressões e sentenças de atribuição**

Continuação da aula passada: Capítulo 7, seções 5 a 7, do livro **Conceitos de Linguagens de Programação** de **Robert W. Sebesta**.

<br>

### **Expressões relacionais e booleanas**

Além das expressões aritméticas, as linguagens de programação oferecem suporte para expressões relacionais e booleandas.

<br>

#### **Expressões relacionais**

Um `operador relacional` é aquele que compara os valores de seus dois operandos. Uma expressão relacional tem os dois operandos e um operador relacional. O valor de uma expressão relacional é booleano, exceto quando valores booleanos não têm um tipo específico incluído na linguagem. Os operadores relacionais são comumente sobrecarregados para uma variedade de tipos. A operação que determina a verdade ou a falsidade de uma expressão relacional depende dos tipos dos operandos. Ela pode ser simples, como para operandos inteiros, ou complexa, como para operandos do tipo cadeia de caracteres. Os tipos dos operandos que podem ser usados para operadores relacionais são tipos numéricos, cadeias e tipos de enumeração.

A sintaxe dos operadores relacionais para igualdade e desigualdade difere entre algumas das linguagens de programação. Por exemplo, para desigualdade, as linguagens baseadas em `C` usam `!=`, `Lua` usa `~=`, `Fortran 95+` usa `.NE.` ou `<>`.

`JavaScript` e `PHP` têm dois operadores relacionais adicionais, `===` e `!==`. Eles são semelhantes aos seus equivalentes `==` e `!=`, mas impedem a coerção de seus operandos. Por exemplo, `"7" == 7` é verdadeiro em JavaScript porque, quando uma cadeia e um número são os operados de um operador relacional, a cadeia sofre uma coerção para um número. Entretanto, `"7" === 7` é falso, porque nenuma coerção é feita nos operandos desse operador.

Os operadores relacionais semptre têm precedência mais baixa que os operadores aritméticos.

<br>

#### **Expressões booleanas**

Expressões booleanas consistem em variáveis booleanas, constantes booleanas, expressões relacionais e operadores booleanos. Os operadores normalmente incluem aqueles para as operações **E**, **OU** e **NÃO** (AND, OR e NOT) e, algumas vezes, para **OU exclusivo** (XOR) e equivalência. Operadores booleanos normalmente recebem apenas operandos booleanos (variáveis booleanas, literais booleanos ou expressões relacionais) e produzem valores booleanos. 

Na matemática de álgebras booleanas, os operadores OU e E devem ter precedência igual. Entretanto, as linguagens baseadas em C atribuem uma precedência maior para o E do que para o OU. Talvez isso tenha derivado da correlação, sem fundamento, da multiplicação com o E e da adição com o OU, o que naturalmente resultaria em uma atribuição de precedência maior para o E. 

Como expressões aritméticas podem ser os operandos de expressões relacionais e expressões relacionais podem ser os operandos de expressões booleanas, as três categorias de operadores devem ser colocadas em diferentes níveis de precedência, relativas umas às outras.

Versões de C anteriores à C99 são exceção entre as linguagens imperativas mais po-pulares, visto que não têm um tipo booleano e, dessa forma, não têm valores booleanos. Em lugar deles, valores numéricos são usados para representar valores booleanos. Em vez de operandos booleanos, são usadas variáveis escalares (numéricas ou caracteres) e constantes, com o zero considerado falso e todos os valores diferentes de zero, verdadeiros. O resultado da avaliação de tal expressão é um inteiro, com o valor 0 se for falsa e 1 se for verdadeira. A aritmética de expressões também pode ser usada para expressões booleanas em C99 e C++.

Um resultado incomum do projeto de C para expressões relacionais é que a seguinte expressão é válida:

```
a > b > c
```

O operador relacional mais à esquerda é avaliado primeiro porque os operadores relacionais em C são associativos à esquerda, produzindo 0 ou 1. Então, esse resultado é comparado com a variável `c`. Nunca existe uma comparação entre `b` e `c` nessa expressão.

Quando os operadores não aritméticos das linguagens baseadas em C são incluídos, existem mais de 40 operadores e ao menos 14 níveis diferentes de precedência. Essa é uma evidência clara da diversidade das coleções de operadores e da complexidade de expressões possíveis nessas linguagens.

A legibilidade determina que uma linguagem deve incluir um tipo booleano em vez de simplesmente usar tipos numéricos em expressões booleanas. Alguma detecção de erros é perdida no uso de tipos numéricos para operandos booleanos, porque qualquer expressão numérica, seja pretendida ou não, é um operando válido para um operador booleano. Nas outras linguagens imperativas, qualquer expressão não booleana usada como operando de um operador booleano é de-tectada como um erro.

<br>

### **Avaliação em Curto-Circuito**

Uma **avaliação em curto-circuito** de uma expressão é uma avaliação na qual o resultado é determinado sem se avaliar todos os operandos e/ou operadores. Por exemplo, o valor da expressão

```
(13 * a) * (b / 13 - 1)
```

é independente de `(b / 13 - 1)` se `a` for igual a `0`. Entretanto, em expressões aritméticas, esse atalho não é facilmente detectado durante a execução, então ele nunca é utilizado. Outro exemplo: o valor da expressão booleana

```
(a >= 0) && (b < 10)
```

é independente da segunda expressão se `a < 0`.

<br>

### **Sentenças de Atribuição**

A sentença de atribuição é uma das construções centrais nas linguagens imperativas. Ela fornece o mecanismo por meio do qual o usuário pode mudar dinamicamente as vinculações de valores a variáveis. 

<br>

#### **Atribuições simples**

Praticamente todas as linguagens de programação usadas atualmente utilizam o sinal de igualdade para o operador de atribuição. Todas elas devem usar algo diferente de um sinal de igualdade para o operador de igualdade relacional, para evitar confusão com seu operador de atribuição.

`ALGOL 60` foi pioneira no uso de `:=` como operador de atribuição, o que evita a confusão da atribuição com a igualdade. `Ada` também usa esse operador de atribuição.

As escolhas de projeto relativas a como as atribuições são usadas em uma linguagem variam bastante. Em algumas linguagens, como `Fortran` e `Ada`, uma atribuição pode aparecer apenas como uma sentença autônoma, e o destino é restringido a uma única variável. Existem, entretanto, muitas alternativas.

<br>

#### **Alvos condicionais**

É também conhecido em várias linguagens como o `operador ternário`.

<br>

#### **Operadores de atribuição compostos**

Um **operador de atribuição composto** é um método de atalho usado para especificar uma forma de atribuição comumente necessária. A forma de atribuição que pode ser abreviada com essa técnica tem a variável de destino aparecendo também como o primeiro operando na expressão no lado direito, como em

```
a = a + b
```

Operadores de atribuição compostos foram introduzidos por `ALGOL 68`, posteriormente foram adotados de uma forma um pouco diferente por `C` e fazem parte de outras linguagens baseadas em `C`, como `Perl`, `JavaScript`, `Python` e `Ruby`. A sintaxe desses operadores de atribuição é a concatenação do operador binário com o operador `=`. Por exemplo,

```
soma += valor;
```

<br>

#### **Operadores de atribuição unários**

As linguagens baseadas em `C`, `Perl` e `JavaScript` incluem dois operadores aritméticos unários especiais que são atribuições abreviadas Eles combinam operações de incremento e decremento com atribuição. Os operadores `++`, para incremento, e `--`, para decremento, podem ser usados tanto em expressões quanto para formar sentenças de atribuição autônomas de um único operador. Eles podem aparecer como operadores pré-fixados, que precedem os operandos, ou como operadores pós-fixados, que vêm após os operandos. Na sentença de atribuição

```
sum = ++ count;
```

o valor de `count` é incrementado em 1 unidade e então atribuído a `sum`. Essa operação também poderia ser declarada como

```
count = count + 1;
sum = count;
```

Se o mesmo operador for usado como um operador pós-fixado, como em

```
sum = count ++;
```

a atribuição do valor de `count` ocorrerá primeiro; então, `count` será incrementado. O efeito é o mesmo das duas sentenças a seguir:

```
sum = count;
count = count + 1;
```

Um exemplo do uso do operador unário de incremento para formar uma sentença de atribuição completa é

```
count ++;
```

que simplesmente incremente `count`.

Quando dois operadores unários são aplicados ao mesmo operando, a associção é da direita para a esquerda. Por exemplo, em

```
- count ++
```

`count` é primeiro incrementado, e então negado.

<br>

#### **Atribuição como uma expressão**

Nas linguagens baseadas em `C`, `Perl` e `JavaScript`, a sentença de atribuição produz um resultado, o qual é o mesmo que o valor atribuído ao alvo. Ela pode, dessa forma, ser usada como uma expressão e como um operando em outras expressões. Esse projeto trata o operador de atribuição de forma bastante similar a qualquer outro operador binário, exceto por ter o efeito colateral de modificar seu operando da esquerda. Por exemplo, em `C`, é comum escrever sentenças como

```c
while ((ch = getchar()) != EOF) {...}
```

Nessa sentença, o próximo caractere do arquivo da entrada padrão, normalmente o teclado, é obtido com `getchar` e atribuído à variável `ch`. O resultado, ou valor atribuído, é então comparado com a constante `EOF`. Se `ch` não for igual a `EOF`, a sentença composta `{...}` será executada. Note que a atribuição precisa estar entre parênteses – nas linguagens que oferecem suporte à atribuição como uma expressão, a precedência do operador de atribuição é menor que a dos operadores relacionais. Sem os parênteses, o novo caractere seria comparado primeiro com `EOF`. Então, o resultado dessa comparação, seja `0` ou `1`, seria atribuído a `ch`.

<br>

#### **Atribuições múltiplas**

Diversas linguagens de programação recentes, incluindo `Python`, fornecem sentenças de atribuição de múltiplos alvos e fontes. Por exemplo, em `Python` é possível escrever

```python
a, b, c = 2, 3, 4
```

---

## **Subprogramas**

Baseado no Capítulo 9 do livro **Conceitos de Linguagens de Programação** de **Robert W. Sebesta**.

<br>

### **Introdução**

Subprogramas são os elementos fundamentais dos programas e, assim, estão entre os conceitos mais importantes no projeto de linguagens de programação.

O primeiro computador programável, a Máquina Analítica de Babbage, construída nos anos 1840, tinha a capacidade de reutilizar coleções de cartões de instrução em vá-rios lugares diferentes de um programa. Em uma linguagem de programação moderna, tal coleção de sentenças é escrita como um subprograma. Esse reúso resulta em econo-mia de espaço de memória e tempo de codificação. Tal reúso é também uma abstração pois os detalhes da computação do subprograma são substituídos em um programa por uma sentença que chama o subprograma. Em vez de descrever como alguma compu-tação deve ser feita em um programa, essa descrição (a coleção de sentenças no sub-programa) é representada por uma sentença de chamada, efetivamente abstraindo os detalhes. Isso aumenta a legibilidade de um programa por enfatizar sua estrutura lógica, ao passo que oculta seus detalhes de baixo nível. 

Os métodos das linguagens orientadas a objetos são intimamente relacionados aos subprogramas. As principais maneiras pelas quais os métodos diferem dos subprogramas são o modo como são chamados e suas associações com clas-ses e objetos.

<br>

### **Fundamentos dos subprogramas**

#### **Características gerais dos subprogramas**

Todos os subprogramas, exceto as corrotinas, têm as seguintes características:

* Cada subprograma tem um único ponto de entrada.
* A unidade de programa chamadora é suspensa durante a execução do subprograma chamado, o que significa que existe apenas um subprograma em execução em determinado momento.
* Quando a execução do subprograma termina, o controle sempre retorna para o chamador.

As alternativas a isso resultam em corrotinas e em unidades concorrentes. Em sua maioria, os subprogramas têm nomes, embora alguns sejam anônimos.

<br>

#### **Definições básicas**

A **definição de um subprograma** descreve a interface e as ações da abstração do subprograma. Uma **chamada de subprograma** é o pedido explícito para que um subprograma específico seja executado. Diz-se que um subprograma está **ativo** se, depois de ser chamado, iniciou a execução, mas ainda não a concluiu.

O **cabeçalho de um subprograma**, que é a primeira parte da definição, tem várias finalidades. Primeiramente, ele especifica que a unidade sintática seguinte é a definição de um subprograma de algum tipo em particular. Nas linguagens que possuem mais de um tipo de subprograma, o tipo do subprograma normalmente é especificado com uma palavra especial. Segundo, se o subprograma não é anônimo, o cabeçalho fornece um nome para ele. Terceiro, o cabeçalho pode especificar uma lista de parâmetros. Ex.:

```python
def adder(parâmetros):
    ...
```

Esse é o cabeçalho de um subprograma em `Python`. Em outras linguagens pode começar com a palavra reservada `function`, ou `fn`. Em `C`, o cabeçalho poderia ser o seguinte:

```c
void adder(parâmetros){
    ...
}
```

onde `void` é uma palavra reservada indicando que o subprograma não retorna um valor.

O corpo dos subprogramas define suas ações. Nas linguagens baseadas em `C` (e em algumas outras – por exemplo, `JavaScript`), o corpo de um subprograma é delimitado por chaves. Em `Ruby`, uma sentença `end` finaliza o corpo de um subprograma. Assim como nas sentenças compostas, as sentenças no corpo de uma função em `Python` devem ser endentadas, e o final do corpo é indicado pela primeira sentença não endentada.

Uma característica das funções Python que as diferencia das funções de outras linguagens de programação comuns é que as sentenças de função `def` são executáveis. Quando uma sentença `def` é executada, ela atribui o nome dado ao corpo da função dada. Até que a sentença `def` de uma função seja executada, a função não pode ser chamada. Considere o exemplo de esqueleto a seguir:

```python
if ... :
    def fun(...):
        ...
else:
    def fun(...):
        ...
```

Se a cláusula `then` dessa construção de seleção é executada, essa versão da função `fun` pode ser chamada, mas não a versão da cláusula `else`. Do mesmo modo, se a cláusula `else` é escolhida, sua versão da função pode ser chamada, mas a que está na cláusula `then` não.

O **perfil de parâmetros** de um subprograma contém o número, a ordem e os tipos de seus parâmetros formais. O **protocolo** de um subprograma é seu perfil de parâmetros, mais seu tipo de retorno (se for uma função). Nas linguagens nas quais os subprogramas têm tipos, esses tipos são definidos pelo protocolo do subprograma.

Os subprogramas podem ter tanto declarações como definições. Essa forma se compara com as declarações e definições de variáveis em `C`, na qual as declarações são usadas para fornecer informação de tipo, mas não para definir variáveis. As declarações de subprograma fornecem o protocolo do subprograma, mas não incluem seus corpos. Elas são necessárias nas linguagens que não permitem referências diretas a subprogramas. Tanto no caso das variáveis como no dos subprogramas, declarações são necessárias para verificação estática de tipos. No caso dos subprogramas, deve ser verificado o tipo dos parâmetros. Declarações de função são comuns em programas `C` e `C++`, onde são denominadas **protótipos**. Muitas vezes, essas declarações são colocadas em arquivos de cabeçalho.

<br>

#### **Parâmetros**

Normalmente, os subprogramas descrevem computações. Há duas maneiras pelas quais um subprograma sem método pode acessar os dados que deve processar: por meio de acesso direto a variáveis não locais (declaradas em outro lugar, mas visíveis no subpro-grama) ou por meio de passagem de parâmetros.

Os dados passados por meio de parâmetros são acessados usando-se nomes locais ao subprograma. A passagem de parâmetros é mais flexível que o acesso direto a variáveis não locais. Basicamente, um subprograma com acesso por meio de parâmetros aos dados a serem processados é uma computação parametrizada. Ele pode fazer sua computação em quaisquer dados que receba por meio de seus parâmetros (presumindo-se que os tipos dos parâmetros são os esperados pelo subprograma).

Se o acesso aos dados é feito por meio de variáveis não locais, o único modo de fazer a computação em diferentes dados é atribuindo novos valores a essas variáveis não locais entre as chamadas ao subprograma. O acesso sistemático a variáveis não locais pode reduzir a confiabilidade. Variáveis que são visíveis para o subprograma onde o acesso é frequentemente desejado acabam sendo visíveis também onde o acesso a elas não é necessário.

Embora os métodos também acessem dados externos por meio de referências e parâmetros não locais, o principal dado a ser processado por um método é o objeto por meio do qual é chamado. Contudo, quando um método acessa dados não locais, os problemas de confiabilidade são os mesmos dos subprogramas sem método. Além disso, em uma linguagem orientada a objetos, o acesso do método a variáveis de classe (aquelas associadas à classe e não a um objeto) está relacionado ao conceito de dados não locais e deve ser evitado quando possível. Nesse caso, assim como no caso de uma função C acessar dados não locais, o método pode ter o efeito colateral de alterar algo que não seja seus parâmetros ou dados locais. Tais alterações complicam a semântica do método e o tornam menos confiável.

Os parâmetros do cabeçalho do subprograma são denominados **parâmetros formais**. Às vezes, eles são considerados variáveis fictícias, pois não são variáveis no sentido usual: na maioria dos casos, são vinculadas ao armazenamento somente quando o subprograma é chamado, e essa vinculação muitas vezes se dá por meio de algumas outras variáveis de programa.

As sentenças de chamada a subprogramas devem incluir o nome do subprograma e uma lista de parâmetros a serem vinculados aos parâmetros formais do subprograma. Esses parâmetros são chamados de **parâmetros reais**. Eles devem ser diferenciados dos parâmetros formais, porque os dois normalmente têm diferentes restrições em suas formas e, é claro, seus usos são bastante diferentes.

Na maioria das linguagens de programação, a correspondência entre parâmetros reais e formais – ou a vinculação de parâmetros reais a parâmetros formais – é feita pela posição: o primeiro parâmetro real é vinculado ao primeiro parâmetro formal e assim por diante. Tais parâmetros são chamados de **parâmetros posicionais**. Esse é um método eficiente e seguro de relacionar parâmetros reais aos seus formais correspondentes, desde que as listas de parâmetros sejam relativamente curtas.

No entanto, quando as listas são longas, é fácil que o programador cometa erros na ordem dos parâmetros reais da lista. Uma solução para esse problema é fornecer **parâmetros de palavra-chave**, nos quais o nome do parâmetro formal ao qual um parâmetro real deve ser vinculado é especificado com o parâmetro real em uma chamada. A vantagem dos parâmetros de palavra-chave é que podem aparecer em qualquer ordem na lista de parâmetros reais. As funções de Python podem ser chamadas com essa técnica, como em

```python
sumer(length = my_length, list = my_array, sum = my_sum)
```

A desvantagem dos parâmetros de palavra-chave é que o usuário do subprograma precisa saber os nomes dos parâmetros formais.

Além dos parâmetros de palavra-chave, algumas linguagens (por exemplo, Python) permitem parâmetros posicionais. Parâmetros de palavra-chave e posicionais podem ser misturados em uma chamada, como em

```python
sumer(my_length, list = my_array, sum = my_sum)
```

A única restrição dessa estratégia é que, depois que um parâmetro de palavra-chave apa-rece na lista, todos os parâmetros restantes devem ser de palavra-chave. Essa restrição é necessária porque uma posição pode não ser mais bem definida depois que um parâmetro de palavra-chave aparecer.

Em Python, Ruby, C++ e PHP, os parâmetros formais podem ter valores padrão. Um valor padrão é usado se nenhum parâmetro real é passado para o parâmetro formal no cabeçalho do subprograma. Considere o seguinte cabeçalho de função em Python:

```python
def compute_pay(income, exemptions = 1, tax_rate)
```

O parâmetro formal exemptions pode estar ausente em uma chamada a com-pute_pay; quando estiver, o valor 1 será usado. A função pode ser chamada como segue:

```python
pay = compute_pay(20000.0, tax_rate = 0.15)
```

<br>

#### **Procedimentos e funções**

Existem duas categorias distintas de subprogramas – procedimentos e funções –, ambas as quais podem ser vistas como estratégias para ampliar a linguagem. Os subprogramas são conjuntos de sentenças que definem computações parametrizadas. As funções retornam valores – os procedimentos, não.

Os procedimentos podem produzir resultados na unidade de programa chamadora por meio de dois métodos: (1) se houver variáveis que não são parâmetros formais, mas que ainda são visíveis no procedimento e na unidade de programa chamadora, o procedimento poderá alterá-las; e (2) se o procedimento tiver parâmetros formais que permitam a transferência de dados para o chamador, esses parâmetros poderão ser alterados.

As funções estabelecem novos operadores definidos pelo usuário. Por exemplo, se uma linguagem não tem um operador de exponenciação, pode ser escrita uma função que retorne o valor de um de seus parâmetros elevado à potência de outro parâmetro. Em C++, seu cabeçalho poderia ser

```c++
float power(float base, float exp)
```

o qual poderia ser chamado com

```c++
result = 3.4 * power(10.0, x);
```

Em algumas linguagens de programação, os usuários podem sobrecarregar operadores, definindo novas funções para eles.

<br>

### **Questões de projeto para subprogramas**

Subprogramas são estruturas complexas e, como consequência, há uma longa lista de questões envolvidas em seu projeto. Um problema óbvio é a escolha de um ou mais métodos de passagem de parâmetros a ser usado. A ampla variedade de estratégias utilizadas em várias linguagens é um reflexo da diversidade de opiniões sobre o assunto. Uma questão intimamente relacionada é se os tipos de parâmetros serão verificados em relação aos tipos dos parâmetros formais correspondentes.

A natureza do ambiente local de um subprograma impõe, até certo ponto, a natureza do subprograma. A questão mais importante aqui é se as variáveis locais são alocadas estática ou dinamicamente.

Em seguida, existe o problema de as definições do subprograma poderem ser ani-nhadas. Outra questão é se nomes de subprograma podem ser passados como parâmetros. Se isso for permitido e a linguagem possibilitar que os subprogramas sejam aninhados, há a questão do ambiente de referenciamento correto de um subprograma passado como parâmetro.

Por último, há as questões de os subprogramas poderem ser sobrecarregados ou genéricos. Um **subprograma sobrecarregado** é aquele cujo nome é igual ao de outro subprograma no mesmo ambiente de referenciamento. Um **subprograma genérico** é aquele cuja computação pode ser feita em dados de diferentes tipos, em diferentes chamadas. Um **fechamento** é um subprograma aninhado e seu ambiente de referenciamento, os quais, juntos, permitem que o subprograma seja chamado a partir de qualquer lugar em um programa.

A seguir, um resumo dessas questões de projeto para subprogramas em geral:

* As variáveis locais são alocadas estática ou dinamicamente?
* Definições de subprograma podem aparecer em outras definições de subprograma?
* Qual método (ou métodos) de passagem de parâmetro é usado?
* Os tipos dos parâmetros são verificados em relação aos tipos dos parâmetros formais?
* Se subprogramas podem ser passados como parâmetros e podem ser aninhados, qual é o ambiente de referenciamento de um subprograma passado?
* São permitidos efeitos colaterais funcionais?
* Quais tipos de valores podem ser retornados de funções?
* Quantos valores podem ser retornados de funções?
* Os subprogramas podem ser genéricos?
* Se a linguagem permite subprogramas aninhados, fechamentos são suportados?

<br>

### **Ambientes de referenciamento local**

<br>

#### **Variáveis locais**

Os subprogramas podem definir suas próprias variáveis, estabelecendo assim ambientes de referenciamento local. As variáveis definidas dentro de subprogramas são denominadas **variáveis locais**, pois seu escopo normalmente é o corpo do subprograma em que são definidas.

Na maioria das linguagens contemporâneas, as variáveis locais de um subprograma são dinâmicas da pilha por padrão. Nas funções de C e C++, as variáveis locais são dinâmicas da pilha, a menos que sejam especificamente declaradas como `static`. Por exemplo, na função C (ou C++) a seguir, a variável `sum` é estática e `count` é dinâmica da pilha.

```c
int adder(int list[], int listlen){
    static int sum = 0;
    int count;
    for (count = 0; count < listlen; count++)
        sum += list[count];

    return sum;
}
```

Os métodos de C++, Java e C# só têm variáveis locais dinâmicas da pilha. Em Python, as únicas declarações usadas em definições de método são para variá-veis globais. Qualquer variável declarada como global em um método deve ser definida fora dele. Uma variável definida fora do método pode ser referenciada nele sem ser declarada como global, mas tal variável não pode ser atribuída no método. Se o nome de uma variável global é atribuído em um método, ela é implicitamente declarada como local, e a atribuição não a perturba. Todas as variáveis locais em métodos Python são dinâmicas da pilha.

<br>

#### **Subprogramas aninhados**

A ideia de aninhar subprogramas se originou com ALGOL 60. O objetivo era atingir a capacidade de criar uma hierarquia de lógica e escopos. Se um subprograma é necessário apenas dentro de outro subprograma, por que não colocá-lo lá e ocultá-lo do restante do programa? Como, normalmente, o escopo estático é usado em linguagens que permitem aninhar subprogramas, isso também proporciona uma maneira altamente estruturada de conceder acesso a variáveis não locais nos subprogramas envolventes.

Por um longo tempo, as únicas linguagens que permitiam subprogramas aninhados eram as diretamente des-cendentes de ALGOL 60, ou seja, ALGOL 68, Pascal e Ada. Muitas outras linguagens, incluindo todas as descendentes diretas de C, não permitem aninhamento de subprogramas. Recentemente, algumas linguagens novas voltaram a permiti-lo. Entre elas estão JavaScript, Python, Ruby e Lua. Além disso, a maioria das linguagens de programação funcionais permite aninhar subprogramas.

<br>

### **Métodos de passagem de parâmetros**

Métodos de passagem de parâmetros são as maneiras pelas quais os parâmetros são transmitidos para e/ou dos subprogramas chamados.

<br>

#### **Modelos semânticos de passagem de parâmetros**

Os parâmetros formais são caracterizados por um dos três diferentes modelos semân-ticos a seguir: (1) podem receber dados do parâmetro real correspondente; (2) podem transmitir dados para o parâmetro real; ou (3) podem fazer as duas coisas. Esses modelos são denominados **modo de entrada**, **modo de saída** e **modo de entrada e saída**, respectivamente.

<br>

#### **Modelos de implementação de passagem de parâmetros**

Diversos modelos foram desenvolvidos pelos projetistas de linguagem para guiar a im-plementação dos três modos básicos de transmissão de parâmetros.

<br>

##### **Passagem por valor**

Quando um parâmetro é **passado por valor**, o valor do parâmetro real é usado para inicializar o parâmetro formal correspondente, o qual atua então como variável local no subprograma, implementando assim a semântica modo de entrada. Normalmente, a passagem por valor é implementada por cópia, pois muitas vezes os acessos são mais eficientes com essa estratégia.

A vantagem da passagem por valor é que, para escalares, ela é rápida, tanto em ter-mos de custo de vinculação como de tempo de acesso. A principal desvantagem do método de passagem por valor, caso sejam utilizadas cópias, é que é necessário armazenamento adicional para o parâmetro formal, ou no subprograma chamado ou em alguma área fora do chamador e do subprograma chamado. Além disso, o parâmetro real precisa ser copiado na área de armazenamento para o parâmetro formal correspondente. O armazenamento e as operações de cópia podem ser dispendiosos, caso o parâmetro seja grande, como um vetor com muitos elementos.

<br>

##### **Passagem por resultado**

Passagem por resultado é um modelo de implementação para parâmetros de modo de saída. Quando um parâmetro é passado por resultado, nenhum valor é transmitido para o subprograma. O parâmetro formal correspondente atua como uma variável local, mas, imediatamente antes que o controle seja devolvido para o chamador, seu valor é transmitido de volta para o parâmetro real do chamador, o qual obviamente deve ser uma variável.

O método de passagem por resultado tem as vantagens e desvantagens da passagem por valor, além de algumas desvantagens adicionais. Se os valores são retornados por cópia (e não por caminhos de acesso), como normalmente acontece, a passagem por re-sultado exige também o armazenamento e as operações de cópia extras necessárias para a passagem por valor. Como na passagem por valor, a dificuldade da implementação da passagem por resultado pela transmissão de um caminho de acesso normalmente resulta em sua implementação por cópia. Nesse caso, o problema é garantir que o valor inicial do parâmetro real não seja usado no subprograma chamado.

<br>

##### **Passagem por valor-resultado**

**Passagem por valor-resultado** é um modelo de implementação para parâmetros de modo de entrada e saída no qual são copiados os valores reais. Trata-se, na verdade, de uma combinação de passagem por valor e passagem por resultado. O valor do parâmetro real é usado para inicializar o parâmetro formal correspondente, o qual atua então como uma variável local. Na verdade, os parâmetros formais da passagem por valor devem ter um armazenamento local associado ao subprograma chamado. Ao término do subprograma, o valor do parâmetro formal é transmitido de volta para o parâmetro real.

Às vezes, a passagem por valor-resultado é chamada de **passagem por cópia**, pois o parâmetro real é copiado no parâmetro formal na entrada do subprograma e, então, copiado de volta no término do subprograma.

A passagem por valor-resultado compartilha com a passagem por valor e com a pas-sagem por resultado as desvantagens de exigir armazenamento múltiplo para parâmetros e o tempo para copiar os valores. Com a passagem por resultado, ela compartilha os problemas associados à ordem em que os parâmetros reais são atribuídos. As vantagens da passagem por valor-resultado são relacionados à passagem por referência.

<br>

##### **Passagem por referência**

**Passagem por referência** é um segundo modelo de implementação para parâmetros de modo de entrada e saída. Contudo, em vez de copiar valores de dados, como na passa-gem por valor-resultado, o método de passagem por referência transmite um caminho de acesso (normalmente apenas um endereço) para o subprograma chamado. Isso fornece o caminho de acesso para a célula que armazena o parâmetro real. Assim, o subprograma chamado pode acessar o parâmetro real na unidade de programa chamadora. Com efeito, o parâmetro real é compartilhado com o subprograma chamado.

A vantagem da passagem por referência é que o processo de passagem em si é eficiente tanto em termos de tempo como de espaço. Não é exigido espaço duplicado e nenhuma cópia é necessária.

No entanto, existem várias desvantagens. Primeiro, o acesso aos parâmetros formais será mais lento que aos parâmetros da passagem por valor, devido ao nível adicional de endereçamento indireto exigido. Segundo, se é necessária apenas comunicação unilateral com o subprograma chamado, podem ser feitas alterações acidentais e erradas no parâmetro real.

Outro problema da passagem por referência é que apelidos podem ser criados. Esse problema deve ser esperado, pois a passagem por referência torna caminhos de acesso disponíveis para os subprogramas chamados, fornecendo assim acesso a variáveis não locais. O problema desses tipos de criação de apelidos é o mesmo de outras circuns-tâncias: é prejudicial à legibilidade e, portanto, à confiabilidade. Isso também torna a verificação de programas mais difícil.

<br>

##### **Passagem por nome**

**Passagem por nome** é um método de transmissão de parâmetros de modo de entrada e saída que não corresponde a um único modelo de implementação. Quando parâmetros são passados por nome, na verdade o parâmetro real é substituído textualmente pelo parâmetro formal correspondente em todas as suas ocorrências no subprograma. Esse método é bem diferente dos discutidos até aqui, em que os parâmetros formais são vinculados a valores reais ou a endereços no momento da chamada do subprograma. Um parâmetro formal passado por nome é vinculado a um método de acesso no momento da chamada do subprograma, mas a vinculação real a um valor ou a um endereço é adiada até que o parâmetro formal seja atribuído ou referenciado.

A implementação de um parâmetro passado por nome exige que um subprograma seja passado para o subprograma chamado a fim de avaliar o endereço ou valor do parâmetro formal. O ambiente de re-ferenciamento do subprograma passado também deve ser passado. Esse subprograma/ ambiente de referenciamento é um fechamento. Os parâmetros passados por nome têm implementação complexa e são ineficientes. Além disso, aumentam significativamente a complexidade do programa, diminuindo com isso sua legibilidade e sua confiabilidade.

Essa passagem não faz parte de nenhuma linguagem amplamente utilizada. No entanto, é usasa em tempo de compilação pelas macros nas linguagens assembly e para parâmetros genéricos dos subprogramas genéricos em C++, Java 5.0 e C# 2005.

<br>

### **Parâmetros que são subprogramas**

Em programação ocorrem várias situações que são tratadas mais convenientemente se os nomes de subprograma puderem ser enviados como parâmetros para outros subpro-gramas. Embora essa ideia seja aparentemente simples, os detalhes de como ela funciona podem ser confusos. Se fosse necessária apenas a transmissão do código do subprograma, ela poderia ser feita passando-se um único ponteiro. Contudo, surgem duas complicações.

Primeiro, há a questão da verificação de tipos dos parâmetros das ativações do sub-programa passado como parâmetro. A segunda complicação com parâmetros que são subprogramas só ocorre em lin-guagens que permitem subprogramas aninhados. A questão é qual ambiente de referenciamento deve ser usado para executar o subprograma passado. São três escolhas:

* O ambiente da sentença de chamada que executa o subprograma passado (**vinculação rasa** - *shallow binding*).
* O ambiente da definição do subprograma passado (**vinculação profunda** - *deep binding*).
* O ambiente da senteça de chamada que passou o subprograma como parâmetro real (**vinculação ad hoc** - *ad hoc binding*).

O exemplo do programa a seguir, escrito com a sintaxe do JavaScript, ilustra essas escolhas:

```js
function sub1(){
    var x;
    function sub2(){
        alert(x); // cria uma caixa de diálogo com o valor de x
    };
    function sub3(){
        var x;
        x = 3;
        sub4(sub2);      
    };
    function sub4(subx){
        var x;
        x = 4;
        subx();
    };
    x = 1;
    sub3();
}
```

Considere a execução de `sub2` quando é chamado em `sub4`. Para vinculação rasa, o ambiente de referenciamento dessa execução é o de `sub4`; portanto, a referência a `x` em `sub2` é vinculada à variável local `x` em `sub4`, e a saída do programa é `4`. Para vinculação profunda, o ambiente de referenciamento da execução de `sub2` é o de `sub1`; portanto, a referência a `x` em `sub2` é vinculada à variável local `x` em `sub1`, e a saída é `1`. Para ad hoc, a vinculação é com a variável local `x` em `sub3`, e a saída é `3`.

<br>

### **Chamada indireta de subprogramas**

Existem situações nas quais os subprogramas devem ser chamados indiretamente. Elas ocorrem com mais frequência quando o subprograma específico a ser chamado não é conhecido até o momento da execução. A chamada ao subprograma é feita por meio de um ponteiro ou de uma referência para o subprograma, configurado(a) durante a execução, antes de a chamada ser feita.

As duas aplicações mais comuns de chamadas indiretas de subprograma são o tratamento de evento em interfaces gráficas do usuário, que agora fazem parte de praticamente todas as aplicações Web, assim como de muitas que não são para a Web; e os *callbacks*, nos quais um subprograma é chamado e instruído a notificar o cha-mador quando tiver concluído seu trabalho. Como sempre, nosso interesse não está nesses tipos específicos de programação, mas no suporte de linguagem de programação para eles.

O conceito de chamadas indiretas a subprogramas não foi desenvolvido recente-mente. C e C++ permitem que um programa defina um ponteiro para uma função, por meio do qual ela pode ser chamada. Em C++, ponteiros para funções são tipados de acordo com o tipo de retorno e os tipos de parâmetros da função; portanto, tal ponteiro só pode apontar para funções com um protocolo específico. Por exemplo, a declaração a seguir define um ponteiro (`pfun`) que pode apontar para qualquer função que receba um `float` e um `int` como parâmetros e retorne um `float`:

```c
float (*pfun) (float, int);
```

Qualquer função com o mesmo protocolo desse ponteiro pode ser usada como valor inicial do ponteiro ou ser atribuída a ele em um programa.

<br>

### **Questões de projeto para funções**

As questões de projeto a seguir são específicas para funções:

* Efeitos colaterais são permitidos?
* Quais tipos de valores podem ser retornados?
* Quantos valores podem ser retornados?

<br>

#### **Efeitos colaterais funcionais**

Devido aos efeitos colaterais de funções chamadas em expressões, parâmetros para funções sempre devem ser modo de entrada.  Esse requisito efetivamente impede que uma função cause efeitos colaterais por meio de seus parâmetros ou da criação de apelidos de parâmetros e variáveis globais. No entanto, na maioria das outras linguagens imperativas as funções podem ter parâmetros passados por valor ou por referência, permitindo assim as funções que causam efeitos colaterais e a criação de apelidos.

<br>

#### **Tipos de valores retornados**

A maioria das linguagens de programação imperativas restringe os tipos que podem ser retornados por suas funções. C permite que qualquer tipo seja retornado por suas funções, exceto vetores e funções. Esses podem ser manipulados por valores de retorno de tipo ponteiro. C++ é como C, mas também permite que tipos definidos pelo usuário, ou classes, sejam retornados por suas funções. Ada, Python, Ruby e Lua são as únicas linguagens entre as imperativas atuais cujas funções (e/ou métodos) podem retornar valores de qualquer tipo.

Em algumas linguagens de programação, os subprogramas são objetos de primeira classe, o que significa que podem ser passados como parâmetros, retornados de funções e atribuídos a variáveis. Métodos são objetos de primeira classe em algumas linguagens imperativas, por exemplo, Python, Ruby e Lua. O mesmo vale para as funções da maioria das linguagens funcionais.

<br>

#### **Números de valores retornados**

Na maioria das linguagens, apenas um valor pode ser retornado de uma função. Contu-do, nem sempre esse é o caso. Ruby, Lua, Matlab, F# permitem o retorno de múltiplos valores. Cada linguagem possui sua forma de retornar os múltiplos valores.

### **Subprogramas sobrecarregados**

Um **subprograma sobrecarregado** é aquele cujo nome é igual ao de outro subprograma no mesmo ambiente de referenciamento. Toda versão de um subprograma sobrecarregado deve ter um protocolo exclusivo; isto é, deve ser diferente dos outros no número, na ordem ou nos tipos de seus parâmetros, e possivelmente em seu tipo de retorno. O significado de uma chamada a um subprograma sobrecarregado é determinado pela lista de parâmetros reais e/ou possivelmente pelo tipo do valor retornado. Embora não seja necessário, os subprogramas sobrecarregados normalmente implementam o mesmo processo.

<br>

### **Subprogramas genéricos**

O reúso pode contribuir muito para a produtividade do software. Um modo de aumentar a reutilização do software é reduzir a necessidade de criar subprogramas distintos que implementem o mesmo algoritmo em diferentes tipos de dados. Por exemplo, não deve-ria ser necessário um programador escrever quatro diferentes subprogramas de ordena-ção para ordenar quatro vetores que só diferem no tipo de elemento.

Um subprograma **polimórfico** recebe parâmetros de tipos diferentes em diferentes ativações. Os subprogramas sobrecarregados fornecem um tipo específico de polimorfismo, chamado **polimorfismo ad hoc**. Os subprogramas sobrecarregados não precisam se comportar de modo semelhante.

As linguagens que suportam programação orientada a objetos normalmente supor-tam polimorfismo de subtipo. Polimorfismo de subtipo significa que uma variável de tipo T pode acessar qualquer objeto de tipo T ou de qualquer tipo derivado de T.

Um tipo mais geral de polimorfismo é fornecido pelos métodos de Python e Ruby. Lembre-se de que, nessas linguagens, as variáveis não têm tipos, de modo que os parâmetros formais também não têm tipos. Portanto, um método funcionará para qualquer tipo de parâmetro real, desde que os operadores usados nos parâmetros formais no método sejam definidos.

O **polimorfismo paramétrico** é fornecido por um subprograma que recebe parâ-metros genéricos usados em expressões de tipo que descrevem os tipos dos parâmetros do subprograma. Diferentes instanciações desses subprogramas podem receber parâmetros genéricos distintos, produzindo subprogramas que recebem diferentes tipos de parâmetros. Todas as definições paramétricas de subprogramas se comportam da mesma forma. Os subprogramas parametricamente polimórficos são frequentemente chamados de subprogramas **genéricos**.

<br>

### **Operadores sobrecarregados definidos pelo usuário**

Operadores podem ser sobrecarregados pelo usuário em Ada, C++, Python e Ruby. Suponha que seja criada uma classe Python para suportar números complexos e operações aritméticas sobre eles. Um número complexo pode ser representado com dois valores de ponto flutuante. Para eles, a classe `Complex` teria membros chamados `real` e `imag`. Em Python, as operações aritméticas binárias são implementadas como chamadas de método enviadas para o primeiro operando, e o segundo operando é enviado como parâmetro. Para adição, o método é denominado `__add__`. Por exemplo, a expressão `x + y` é implementada como `x.__add__(y)`. A fim de sobrecarregar `+` para a adição de objetos da nova classe `Complex`, só precisamos fornecer a `Complex` um método denominado `__add__` que efetue a operação. Tal método aparece a seguir:

```python
def __add__(self, second):
    return Complex(self.real + second.real, self.imag + second.img)
```

Na maioria das linguagens que suportam programação orientada a objetos, uma referência para o objeto atual é enviada implicitamente com cada chamada de método. Em Python, essa referência deve ser enviada explicitamente; é por isso que `self` é o primeiro parâmetro de nosso método `__add__`.

<br>

### **Fechamentos**

Definir um **fechamento** é simples: é um subprograma e o ambiente de referenciamento onde foi definido. O ambiente de referenciamento é necessário se o subprograma pode ser chamado a partir de qualquer lugar arbitrário no programa. Explicar um fechamento não é tão simples.

Se uma linguagem de programação de escopo estático não permite subprogramas aninhados, os fechamentos não têm utilidade, de modo que tal linguagem não oferece suporte para eles. Todas as variáveis no ambiente de referenciamento de um subprograma em tal linguagem (suas variáveis locais e as variáveis globais) são acessíveis, independentemente do lugar no programa onde o subprograma é chamado.

Quando subprogramas podem ser aninhados, além das variáveis locais e globais, o seu ambiente de referenciamento pode incluir as variáveis definidas em todos os subprogramas que o envolvem. No entanto, isso não é problema se o subprograma só pode ser chamado em lugares onde todos os escopos que o envolvem são ativos e visíveis. Isso se torna um problema se um subprograma pode ser chamado em outro lugar. Isso pode acontecer se o subprograma puder ser passado como parâmetro ou atribuído a uma variável, o que permite que seja chamado praticamente a partir de qualquer lugar no programa. Há um problema associado: o subprograma pode ser chamado depois de um ou mais de seus subprogramas aninhadores ter terminado, o que normalmente significa que as variáveis definidas em tais subprogramas aninhadores foram liberadas – elas não existem mais. Para que o subprograma possa ser chamado a partir de qualquer lugar no programa, seu ambiente de referenciamento deve estar disponível em todo lugar em que ele possa ser chamado. Portanto, as variáveis definidas nos subprogramas aninhadores talvez precisem de tempos de vida do programa inteiro, em vez de apenas o tempo durante o qual o subprograma em que foram definidos estiver ativo. Diz-se que uma variável cujo tempo de vida é o do programa inteiro tem **extensão ilimitada**. Isso nor-malmente significa que ela deve ser dinâmica do monte, em vez de dinâmica da pilha.

Quase todas as linguagens de programação funcionais, a maioria das linguagens de scripting e pelo menos uma linguagem principalmente imperativa, C#, suportam fechamentos. Essas linguagens têm escopo estático, permitem subprogramas aninhados possibilitam que subprogramas sejam passados como parâmetros. A seguir, temos um exemplo de fechamento escrito em JavaScript:

```js
function makeAdder(x){
    return function(y) {return x + y;}
}
...
var add10 = makeAdder(10);
var add5 = makeAdder(5);
document.write("Add 10 to 20: " + add10(20) + "<br />");
document.write("Add 5 to 20: " + add5(20) + "<br />");
```

A saída desse código, supondo que foi embutido em um documento HTML e exibido com um navegador, é a seguinte:

```
Add 10 to 20: 30
Add 5 to 20: 25
```

Nesse exemplo, o fechamento é a função anônima definida dentro da função `makeAdder`, a qual `makeAdder` retorna. A variável `x` referenciada na função de fechamento é vinculada ao parâmetro enviado para `makeAdder`. A função `makeAdder` é chamada duas vezes, uma com o parâmetro `10` e uma com o `5`. Cada uma dessas chamadas retorna uma versão diferente do fechamento, pois são vinculadas a diferentes valores de `x`. A primeira chamada a `makeAdder` cria uma função que soma `10` ao seu parâmetro; a segunda cria uma função que soma `5` ao seu parâmetro. As duas versões da função são vinculadas a diferentes ativações de `makeAdder`. Obviamente, o tempo de vida da versão de `x` criada quando `makeAdder` é chamada deve ultrapassar o tempo de vida do programa.

<br>

### **Corrotinas**

**Corrotina** é um tipo especial de subprograma. Em vez de viabilizar um relacionamento mestre-escravo entre um subprograma chamador e um chamado existente em subpro-gramas convencionais, as corrotinas chamadoras e chamadas são mais equitativas. Na verdade, o mecanismo de controle de corrotinas é muitas vezes chamado de **modelo de controle de unidades simétrico**.

As corrotinas podem ter vários pontos de entrada, os quais são controlados por elas próprias. Elas também têm meios de manter seu status entre ativações. Isso significa que devem ser sensíveis ao histórico de execução e, assim, ter variáveis estáticas locais. Execuções secundárias de uma corrotina frequentemente começam em pontos diferentes de seu início. Por isso, a invocação de uma corrotina é denominada **retomada** (resume) em vez de chamada.

Por exemplo, considere o esqueleto de corrotina:

```
sub co1(){
    ...
    resume co2();
    ...
    resume co3();
    ...
}
```

Na primeira vez que `co1` é retomada, sua execução começa na primeira sentença e executa para baixo até (e incluindo) a retomada de `co2`, o que transfere o controle para `co2`. Na próxima vez que `co1` é retomada, sua execução começa na primeira sentença após sua chamada a `co2`. Quando `co1` é retomada pela terceira vez, sua execução começa na primeira sentença após a retomada de `co3`.

Uma das características comuns dos subprogramas é mantida nas corrotinas: apenas uma está realmente em execução em dado momento.

Como vimos no exemplo acima, em vez de executar até o final, muitas vezes uma corrotina executa parcialmente e, então, transfere o controle para alguma outra corrotina; e, quando é reiniciada, uma corrotina retoma a execução imediatamente após a sentença que utilizou para transferir o controle para outro lugar. Esse tipo de sequência de execução intercalada está relacionado ao funcionamento dos sistemas operacionais de multiprogramação. Embora possam estar em apenas um processador, em tal sistema, todos os programas em execução parecem ser concorrentes enquanto compartilham o processador. No caso das corrotinas, isso às vezes é chamado de **quase concorrência**.

---

## **Vídeos**

* [How to use functions in Python](https://www.youtube.com/watch?v=NSbOtYzIQI0)
* [Sua linguagem não é especial (Parte 1)](https://www.youtube.com/watch?v=p9-WuJbVHHc)
* [Sua linguagem não é especial (Parte 2)](https://www.youtube.com/watch?v=XcTTajFENHI&t=651s)

---

## **Exercícios**

[Exercício de funções em Python do pythonbrasil](https://wiki.python.org.br/ExerciciosFuncoes).